image: registry.gitlab.com/fyjaan983/ci-cd-automation-through-jenkins/liquibase-psql:latest

stages:
  - docker_build
  - build
  - clone
  - test
  - deploy
  - cleanup

# ---------------- DOCKER BUILD & PUSH ----------------
docker_build:
  stage: docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script: |
    echo "Building custom Liquibase+psql Docker image..."
    docker build -t $CI_REGISTRY_IMAGE/liquibase-psql:latest .
    echo "Pushing image to GitLab registry..."
    docker push $CI_REGISTRY_IMAGE/liquibase-psql:latest
  only:
    refs: [main]

# ---------------- BUILD STAGE ----------------
build_job:
  stage: build
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  script: |
    echo "===== BUILD: validate changelog (Liquibase) ====="
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
    liquibase --url="jdbc:postgresql://db:5432/$POSTGRES_DB" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml validate
  artifacts:
    paths: [build_log.txt]
    expire_in: 1 week
  only:
    refs: [main]

# ---------------- CREATE TEMP CLONE DB (dump as artifact) ----------------
db_clone:
  stage: clone
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    set -e
    DBNAME="clone_${CI_COMMIT_SHORT_SHA}"
    echo "Creating temp DB: $DBNAME"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE IF EXISTS \"$DBNAME\";"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE \"$DBNAME\";"

    echo "Applying schema/data from repo into $DBNAME ..."
    if [ -f changelog.xml ]; then
      echo "Found changelog.xml -> applying via Liquibase"
      liquibase --url="jdbc:postgresql://db:5432/$DBNAME" \
                --username="$POSTGRES_USER" \
                --password="$POSTGRES_PASSWORD" \
                --changeLogFile=changelog.xml update
    else
      # Apply SQL files if present. Prefer ./sql/*.sql, else search current repo depth.
      if ls sql/*.sql >/dev/null 2>&1; then
        echo "Applying sql/*.sql in sorted order"
        for f in $(ls sql/*.sql | sort); do
          echo "Applying $f"
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      elif ls *.sql >/dev/null 2>&1 || find . -maxdepth 2 -type f -name "*.sql" | grep -q .; then
        echo "Applying all *.sql found at repo root (depth<=2) in sorted order"
        find . -maxdepth 2 -type f -name "*.sql" | sort | while read -r f; do
          echo "Applying $f"
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      else
        echo "ERROR: No changelog.xml and no .sql files found to build the DB."
        exit 1
      fi
    fi

    echo "Dumping $DBNAME to artifact clone.dump (custom format)"
    pg_dump -h db -U "$POSTGRES_USER" -d "$DBNAME" -Fc -f clone.dump

    # Save DBNAME for later jobs
    printf "DBNAME=%s\n" "$DBNAME" > clone.env
  artifacts:
    reports:
      dotenv: clone.env
    paths:
      - clone.dump
      - clone.env
    expire_in: 2 hours
  only:
    refs: [main]

# ---------------- TEST JOB (recreate DB from dump, then validate) ----------------
# ---------------- TEST JOB (recreate DB from dump) ----------------
test_job:
  stage: test
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  needs: ["db_clone"]
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    # Wait for DB to be ready
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB ($i)"; sleep 2)
    done
    # Load DBNAME from artifact
    source clone.env
    echo "Will test DB: $DBNAME"
    # Drop if exists and recreate database
    if psql -h db -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DBNAME';" | grep -q 1; then
      psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE \"$DBNAME\";"
    fi
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE \"$DBNAME\";"
    # Restore dump safely
    pg_restore -h db -U "$POSTGRES_USER" -d "$DBNAME" --no-owner --clean --if-exists clone.dump
  script:
    - echo "Database $DBNAME restored successfully from dump."

    # Test Case 1: Syntax validation for all SQL files
    - echo "Running syntax validation on SQL files..."
    - |
      for file in $(git ls-files '*.sql'); do
        echo "Checking syntax in $file"
        psql -v ON_ERROR_STOP=1 -q -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$file"
      done

    # Test Case 2: Check Employees.sql data for salaries < 10000
    - echo "Checking Employees table for salaries < 10000..."
    - |
      count=$(psql -h db -U "$POSTGRES_USER" -d "$DBNAME" -tAc "SELECT COUNT(*) FROM EMPLOYEE WHERE salary < 10000;")
      if [ "$count" -gt 0 ]; then
        echo "Found $count employees with salary < 10000"
        exit 1
      else
        echo "No employees found with salary < 10000"
      fi
  artifacts:
    paths: [test_log.txt]
    expire_in: 1 week
  only:
    refs: [main]
# ---------------- DEPLOY TO UAT (simulated) ----------------
deploy_uat:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d postgres -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    echo "===== DEPLOY UAT (simulated) ====="
    exists=$(psql -h db -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='uatdb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE uatdb;"
    fi
    liquibase --url="jdbc:postgresql://db:5432/uatdb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
    echo "UAT deploy complete."
  when: manual
  environment:
    name: uat
  only:
    refs: [main]
  after_script:
    - |
      set -e
      apk add --no-cache msmtp mailx >/dev/null 2>&1 || true
      cat > ~/.msmtprc <<EOF
      account default
      host smtp.gmail.com
      port 587
      auth on
      user fyjaan983@gmail.com
      password $SMTP_PASSWORD
      from fyjaan983@gmail.com
      tls on
      tls_starttls on
      EOF
      chmod 600 ~/.msmtprc || true
      if [ "$CI_JOB_STATUS" = "success" ]; then
        printf "UAT deployment succeeded for commit %s on %s\nLogs: %s\n" "$CI_COMMIT_SHORT_SHA" "$CI_COMMIT_REF_NAME" "$CI_JOB_URL" | mail -s "GitLab Pipeline Success (UAT)" fyjaan983@gmail.com || true
      else
        printf "UAT deployment FAILED for commit %s on %s\nLogs: %s\n" "$CI_COMMIT_SHORT_SHA" "$CI_COMMIT_REF_NAME" "$CI_JOB_URL" | mail -s "GitLab Pipeline FAILED (UAT)" fyjaan983@gmail.com || true
      fi

# ---------------- DEPLOY TO PROD (simulated) ----------------
deploy_prod:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d postgres -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    echo "===== DEPLOY PROD (simulated) ====="
    exists=$(psql -h db -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='proddb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE proddb;"
    fi
    liquibase --url="jdbc:postgresql://db:5432/proddb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
    echo "PROD deploy complete."
  when: manual
  environment:
    name: production
  only:
    refs: [main]
  after_script:
    - |
      set -e
      apk add --no-cache msmtp mailx >/dev/null 2>&1 || true
      cat > ~/.msmtprc <<EOF
      account default
      host smtp.gmail.com
      port 587
      auth on
      user fyjaan983@gmail.com
      password $SMTP_PASSWORD
      from fyjaan983@gmail.com
      tls on
      tls_starttls on
      EOF
      chmod 600 ~/.msmtprc || true
      if [ "$CI_JOB_STATUS" = "success" ]; then
        printf "PROD deployment succeeded for commit %s on %s\nLogs: %s\n" "$CI_COMMIT_SHORT_SHA" "$CI_COMMIT_REF_NAME" "$CI_JOB_URL" | mail -s "GitLab Pipeline Success (PROD)" fyjaan983@gmail.com || true
      else
        printf "PROD deployment FAILED for commit %s on %s\nLogs: %s\n" "$CI_COMMIT_SHORT_SHA" "$CI_COMMIT_REF_NAME" "$CI_JOB_URL" | mail -s "GitLab Pipeline FAILED (PROD)" fyjaan983@gmail.com || true
      fi

# ---------------- CLEANUP (mostly no-op; services are ephemeral) ----------------
rollback_clone:
  stage: cleanup
  image: postgres:15
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  before_script:
    - export PGPASSWORD="$POSTGRES_PASSWORD"
  script:
    - echo "Running rollback cleanup because a stage failed..."
    # Add rollback SQL or restore commands here if needed
    - echo "Rollback/cleanup completed."
  when: on_failure
  only:
    refs: [main]
    
