stages:
  - docker_build
  - build
  - test
  - deploy

# ---------------- DOCKER BUILD & PUSH ----------------
docker_build:
  stage: docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script: |
    echo "Building custom Liquibase+psql Docker image..."
    docker build -t $CI_REGISTRY_IMAGE/liquibase-psql:latest .
    echo "Pushing image to GitLab registry..."
    docker push $CI_REGISTRY_IMAGE/liquibase-psql:latest
  only:
    refs:
      - main

# ---------------- BUILD STAGE ----------------
build_job:
  stage: build
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  script: |
    echo "===== BUILD: validate changelog (Liquibase) ====="
    for i in $(seq 1 20); do
      liquibase --url="jdbc:postgresql://db:5432/$POSTGRES_DB" --username=$POSTGRES_USER --password=$POSTGRES_PASSWORD --changeLogFile=changelog.xml status && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
    echo "Running liquibase validate..."
    liquibase --url="jdbc:postgresql://db:5432/$POSTGRES_DB" --username=$POSTGRES_USER --password=$POSTGRES_PASSWORD --changeLogFile=changelog.xml validate
  artifacts:
    paths:
      - build_log.txt
    expire_in: 1 week
  only:
    refs:
      - main

# Test job: runs only if .sql files change
test_job:
  stage: test
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD=$POSTGRES_PASSWORD
  script: |
    echo "===== TEST: prepare DBs and apply changelog to testdb =====" | tee test_log.txt

    for DBNAME in testdb uatdb proddb; do
      exists=$(psql -h db -U $POSTGRES_USER -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DBNAME';")
      if [ "$exists" != "1" ]; then
        echo "Creating database $DBNAME" | tee -a test_log.txt
        psql -h db -U $POSTGRES_USER -d postgres -c "CREATE DATABASE $DBNAME;" | tee -a test_log.txt
      else
        echo "Database $DBNAME already exists" | tee -a test_log.txt
      fi
    done

    echo "Applying changelog to testdb..." | tee -a test_log.txt
    liquibase --url="jdbc:postgresql://db:5432/testdb" --username=$POSTGRES_USER --password=$POSTGRES_PASSWORD --changeLogFile=changelog.xml update | tee -a test_log.txt

    echo "Verifying row counts and constraints..." | tee -a test_log.txt
    deptCount=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM department;" | xargs); echo "department count: $deptCount" | tee -a test_log.txt
    if [ "$deptCount" -ne 12 ]; then echo "ERROR: expected 12 departments but got $deptCount" | tee -a test_log.txt; exit 1; fi
    empCount=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM employee;" | xargs); echo "employee count: $empCount" | tee -a test_log.txt
    if [ "$empCount" -ne 12 ]; then echo "ERROR: expected 12 employees but got $empCount" | tee -a test_log.txt; exit 1; fi
    orphanCount=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM employee e LEFT JOIN department d ON e.dept_id=d.dept_id WHERE d.dept_id IS NULL;" | xargs); echo "orphan employees count: $orphanCount" | tee -a test_log.txt
    if [ "$orphanCount" -ne 0 ]; then echo "ERROR: $orphanCount employees have invalid dept_id" | tee -a test_log.txt; exit 1; fi
    salaryBad=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM employee WHERE salary <= 0 OR salary IS NULL;" | xargs); echo "invalid salary rows: $salaryBad" | tee -a test_log.txt
    if [ "$salaryBad" -ne 0 ]; then echo "ERROR: $salaryBad rows with non-positive or null salary" | tee -a test_log.txt; exit 1; fi
     echo  "Check for duplicate department IDs"
    dupDept=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM (SELECT dept_id, COUNT(*) c FROM department GROUP BY dept_id HAVING COUNT(*)>1) sub;" | xargs); 
    echo "duplicate dept_id count: $dupDept" | tee -a test_log.txt
    if [ "$dupDept" -ne 0 ]; then echo "ERROR: duplicate dept_id found"; exit 1; fi

    echo  "Ensure all employees are assigned to a department"
    nullDept=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM employee WHERE dept_id IS NULL;" | xargs); 
    echo "employees with null dept_id: $nullDept" | tee -a test_log.txt
    if [ "$nullDept" -ne 0 ]; then echo "ERROR: employees without dept assignment"; exit 1; fi

    echo "Ensure salaries are within a valid business range (e.g., 10,000–200,000)"
    salaryRange=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM employee WHERE salary < 10000 OR salary > 200000;" | xargs); 
    echo "employees with salary outside 10k–200k: $salaryRange" | tee -a test_log.txt
    if [ "$salaryRange" -ne 0 ]; then echo "ERROR: salary out of expected range"; exit 1; fi

    echo  "Ensure department names are not null or empty"
    emptyDeptName=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM department WHERE dept_name IS NULL OR TRIM(dept_name)='';" | xargs);
    echo "departments with empty name: $emptyDeptName" | tee -a test_log.txt
    if [ "$emptyDeptName" -ne 0 ]; then echo "ERROR: found departments with invalid name"; exit 1; fi

    echo  "Verify each department has at least one employee"
    deptNoEmp=$(psql -h db -U $POSTGRES_USER -d testdb -t -c "SELECT COUNT(*) FROM department d WHERE NOT EXISTS (SELECT 1 FROM employee e WHERE e.dept_id=d.dept_id);" | xargs);
    echo "departments with no employees: $deptNoEmp" | tee -a test_log.txt
    if [ "$deptNoEmp" -ne 0 ]; then echo "WARNING: some departments have no employees"; fi

    echo "All tests passed." | tee -a test_log.txt
  artifacts:
    paths:
      - test_log.txt
    expire_in: 1 week
  only:
    refs:
      - main

# ---------------- DEPLOY TO UAT (simulated) ----------------
deploy_uat:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD=$POSTGRES_PASSWORD
  script: |
    echo "===== DEPLOY UAT (simulated) ====="
    exists=$(psql -h db -U $POSTGRES_USER -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='uatdb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U $POSTGRES_USER -d postgres -c "CREATE DATABASE uatdb;"
    fi
    echo "Applying changelog to uatdb (simulated UAT)..."
    liquibase --url="jdbc:postgresql://db:5432/uatdb" --username=$POSTGRES_USER --password=$POSTGRES_PASSWORD --changeLogFile=changelog.xml update
    echo "UAT deploy complete."
  when: manual
  environment:
    name: uat
  only:
    refs:
      - main

# ---------------- EMAIL NOTIFICATION: UAT ----------------
notify_uat_success:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache mailx msmtp
    - echo "defaults" > ~/.mailrc
    - echo "account default" >> ~/.mailrc
    - echo "host smtp.gmail.com" >> ~/.mailrc
    - echo "port 587" >> ~/.mailrc
    - echo "auth on" >> ~/.mailrc
    - echo "user fyjaan983@gmail.com" >> ~/.mailrc
    - echo "password $SMTP_PASSWORD" >> ~/.mailrc
    - echo "from fyjaan983@gmail.com" >> ~/.mailrc
  script: |
    echo "UAT deployment succeeded for commit $CI_COMMIT_SHORT_SHA on branch $CI_COMMIT_REF_NAME by $GITLAB_USER_NAME. 
    See pipeline: $CI_PIPELINE_URL" \
    | mailx -s "GitLab Pipeline SUCCESS: UAT Deploy" fyjaan983@gmail.com
  when: on_success
  needs: ["deploy_uat"]
  only:
    refs:
      - main

notify_uat_failure:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache mailx msmtp
    - echo "defaults" > ~/.mailrc
    - echo "account default" >> ~/.mailrc
    - echo "host smtp.gmail.com" >> ~/.mailrc
    - echo "port 587" >> ~/.mailrc
    - echo "auth on" >> ~/.mailrc
    - echo "user fyjaan983@gmail.com" >> ~/.mailrc
    - echo "password $SMTP_PASSWORD" >> ~/.mailrc
    - echo "from fyjaan983@gmail.com" >> ~/.mailrc
  script: |
    echo "UAT deployment FAILED for commit $CI_COMMIT_SHORT_SHA on branch $CI_COMMIT_REF_NAME by $GITLAB_USER_NAME. 
    See pipeline: $CI_PIPELINE_URL
    
    Job Logs:
    -------------------
    $(cat deploy_uat.log)" \
    | mailx -s "GitLab Pipeline FAILURE: UAT Deploy" fyjaan983@gmail.com
  when: on_failure
  needs: ["deploy_uat"]
  only:
    refs:
      - main


# ---------------- DEPLOY TO PROD (simulated) ----------------
deploy_prod:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD=$POSTGRES_PASSWORD
  script: |
    echo "===== DEPLOY PROD (simulated) ====="
    exists=$(psql -h db -U $POSTGRES_USER -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='proddb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U $POSTGRES_USER -d postgres -c "CREATE DATABASE proddb;"
    fi
    echo "Applying changelog to proddb (simulated PROD)..."
    liquibase --url="jdbc:postgresql://db:5432/proddb" --username=$POSTGRES_USER --password=$POSTGRES_PASSWORD --changeLogFile=changelog.xml update
    echo "PROD deploy complete."
  when: manual
  environment:
    name: production
  only:
    refs:
      - main

  # ---------------- EMAIL NOTIFICATION: PROD ----------------
notify_prod_success:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache mailx msmtp
    - echo "defaults" > ~/.mailrc
    - echo "account default" >> ~/.mailrc
    - echo "host smtp.gmail.com" >> ~/.mailrc
    - echo "port 587" >> ~/.mailrc
    - echo "auth on" >> ~/.mailrc
    - echo "user fyjaan983@gmail.com" >> ~/.mailrc
    - echo "password $SMTP_PASSWORD" >> ~/.mailrc
    - echo "from fyjaan983@gmail.com" >> ~/.mailrc
  script: |
    echo "Production deployment succeeded for commit $CI_COMMIT_SHORT_SHA on branch $CI_COMMIT_REF_NAME by $GITLAB_USER_NAME. 
    See pipeline: $CI_PIPELINE_URL" \
    | mailx -s "GitLab Pipeline SUCCESS: PROD Deploy" fyjaan983@gmail.com
  when: on_success
  needs: ["deploy_prod"]
  only:
    refs:
      - main

notify_prod_failure:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache mailx msmtp
    - echo "defaults" > ~/.mailrc
    - echo "account default" >> ~/.mailrc
    - echo "host smtp.gmail.com" >> ~/.mailrc
    - echo "port 587" >> ~/.mailrc
    - echo "auth on" >> ~/.mailrc
    - echo "user fyjaan983@gmail.com" >> ~/.mailrc
    - echo "password $SMTP_PASSWORD" >> ~/.mailrc
    - echo "from fyjaan983@gmail.com" >> ~/.mailrc
  script: |
    echo "❌ Production deployment FAILED for commit $CI_COMMIT_SHORT_SHA on branch $CI_COMMIT_REF_NAME by $GITLAB_USER_NAME. 
    See pipeline: $CI_PIPELINE_URL
    
    Job Logs:
    -------------------
    $(cat deploy_prod.log)" \
    | mailx -s "GitLab Pipeline FAILURE: PROD Deploy" fyjaan983@gmail.com
  when: on_failure
  needs: ["deploy_prod"]
  only:
    refs:
      - main

