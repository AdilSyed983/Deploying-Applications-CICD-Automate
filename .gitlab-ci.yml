image: registry.gitlab.com/fyjaan983/ci-cd-automation-through-jenkins/liquibase-psql:latest

stages:
  - docker_build
  - build
  - clone
  - test
  - deploy
  - cleanup

# ---------------- DOCKER BUILD & PUSH ----------------
docker_build:
  stage: docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script: |
    echo "Building custom Liquibase+psql Docker image..."
    docker build -t $CI_REGISTRY_IMAGE/liquibase-psql:latest .
    echo "Pushing image to GitLab registry..."
    docker push $CI_REGISTRY_IMAGE/liquibase-psql:latest
  only:
    refs: [main]

# ---------------- BUILD STAGE ----------------
build_job:
  stage: build
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  script: |
    echo "===== BUILD: validate changelog (Liquibase) ====="
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
    liquibase --url="jdbc:postgresql://db:5432/$POSTGRES_DB" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml validate
  artifacts:
    paths: [build_log.txt]
    expire_in: 1 week
  only:
    refs: [main]
#-----------------------------------------------------------------------------  
# Save a copy of the repo files after build
save_good_state:
  stage: build
  script:
    - echo "Saving current state of repository..."
    - mkdir -p ../good_state
    - cp -r . ../good_state
  artifacts:
    paths:
      - ../good_state/
    expire_in: 1 week
  only:
    refs: [main]

# ---------------- CREATE TEMP CLONE DB (dump as artifact) ----------------
db_clone:
  stage: clone
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    set -e
    DBNAME="clone_${CI_COMMIT_SHORT_SHA}"
    echo "Creating temp DB: $DBNAME"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE IF EXISTS \"$DBNAME\";"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE \"$DBNAME\";"

    echo "Applying schema/data from repo into $DBNAME ..."
    if [ -f changelog.xml ]; then
      echo "Found changelog.xml -> applying via Liquibase"
      liquibase --url="jdbc:postgresql://db:5432/$DBNAME" \
                --username="$POSTGRES_USER" \
                --password="$POSTGRES_PASSWORD" \
                --changeLogFile=changelog.xml update
    else
      # Apply SQL files if present. Prefer ./sql/*.sql, else search current repo depth.
      if ls sql/*.sql >/dev/null 2>&1; then
        echo "Applying sql/*.sql in sorted order"
        for f in $(ls sql/*.sql | sort); do
          echo "Applying $f"
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      elif ls *.sql >/dev/null 2>&1 || find . -maxdepth 2 -type f -name "*.sql" | grep -q .; then
        echo "Applying all *.sql found at repo root (depth<=2) in sorted order"
        find . -maxdepth 2 -type f -name "*.sql" | sort | while read -r f; do
          echo "Applying $f"
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      else
        echo "ERROR: No changelog.xml and no .sql files found to build the DB."
        exit 1
      fi
    fi

    echo "Dumping $DBNAME to artifact clone.dump (custom format)"
    pg_dump -h db -U "$POSTGRES_USER" -d "$DBNAME" -Fc -f clone.dump

    # Save DBNAME for later jobs
    printf "DBNAME=%s\n" "$DBNAME" > clone.env
  artifacts:
    reports:
      dotenv: clone.env
    paths:
      - clone.dump
      - clone.env
    expire_in: 2 hours
  only:
    refs: [main]

# ---------------- TEST JOB (recreate DB from dump, then validate) ----------------
# test_job:
#   stage: test
#   image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
#   services:
#     - name: postgres:15
#       alias: db
#   variables:
#     POSTGRES_USER: postgres
#     POSTGRES_PASSWORD: postgres
#     POSTGRES_DB: postgres
#     DNAME: testdb
#   before_script: |
#     set -e
#     export PGPASSWORD="$POSTGRES_PASSWORD"
#
#     # Wait for Postgres to be ready
#     for i in $(seq 1 30); do
#       psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB ($i)"; sleep 2)
#     done
#     echo "Database is ready."
#
#     # Drop & recreate the test database
#     psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE IF EXISTS $DNAME;"
#     psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE $DNAME;"
#   script:
#     # Apply all SQL files from the repo (sorted), fail-fast on first error
#     - |
#       set -e
#       : > test_log.txt
#       files="$(git ls-files '*.sql' | sort)"
#       if [ -z "$files" ]; then
#         echo "No .sql files found in repo" | tee -a test_log.txt
#         exit 1
#       fi
#       echo "Applying SQL files to $DNAME:" | tee -a test_log.txt
#       echo "$files" | tee -a test_log.txt
#
#       for file in $files; do
#         echo "Applying $file" | tee -a test_log.txt
#         if ! psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DNAME" -f "$file" >> test_log.txt 2>&1; then
#           echo "Execution failed in file: $file" | tee -a test_log.txt
#           exit 1
#         fi
#       done
#       echo "All SQL files applied successfully." | tee -a test_log.txt
#
#     # Ensure table exists before content checks
#     - |
#       exists=$(psql -h db -U "$POSTGRES_USER" -d "$DNAME" -tAc "SELECT to_regclass('public.employee');")
#       if [ "$exists" != "public.employee" ]; then
#         echo "Table 'employee' not found after applying SQL. Failing test." | tee -a test_log.txt
#         exit 1
#       else
#         echo "Found table 'employee'." | tee -a test_log.txt
#       fi
#
#     #  Test: no salaries < 10000
#     - |
#       count=$(psql -h db -U "$POSTGRES_USER" -d "$DNAME" -tAc "SELECT COUNT(*) FROM employee WHERE salary < 10000;")
#       echo "Employees with salary < 10000: $count" | tee -a test_log.txt
#       if [ "$count" -gt 0 ]; then
#         echo "Test failed: Found $count employees with salary < 10000" | tee -a test_log.txt
#         exit 1
#       else
#         echo "Test passed: No employees with salary < 10000" | tee -a test_log.txt
#       fi
#   artifacts:
#     when: always
#     paths:
#       - test_log.txt
#     expire_in: 1 week
#   only:
#     refs: [main]
#################################################################
test_job:
  stage: test
  image: alpine:latest
  script:
    - echo "Checking Employees.sql for salary < 10000"
    - |
      if grep -i "insert" Employees.sql | \
        awk -F'[(), ]+' '{for(i=1;i<=NF;i++) if(tolower($i)=="values"){print $(i+4)}}' | \
        awk '{if($1<10000){print "Found salary < 10000: "$1; exit 1}}'; then
        echo "All salaries are above threshold limit"
      else
        echo "Fail: Employees.sql check failed"
        touch test_fail_employees
        
      fi

    - echo "Checking Department.sql for duplicate DEPT_ID"
    - |
      if grep -i "insert" Department.sql | \
        awk -F'[(), ]+' '{for(i=1;i<=NF;i++) if(tolower($i)=="values"){print $(i+1)}}' | \
        sort | uniq -d | grep .; then
        echo "Duplicate DEPT_ID found"
        touch test_fail_department
      else
        echo "No duplicates"
      fi

  
    - |
      if [ -f test_fail_employees ] || [ -f test_fail_department ]; then
        exit 1
      fi
  artifacts:
    paths:
      - test_fail_employees
      - test_fail_department
    when: always   
    expire_in: 48 hours
  only:
    refs: [main]
# ---------------- DEPLOY TO UAT (simulated) ----------------
deploy_uat:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d postgres -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    echo "===== DEPLOY UAT (simulated) ====="
    exists=$(psql -h db -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='uatdb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE uatdb;"
    fi
    liquibase --url="jdbc:postgresql://db:5432/uatdb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
    echo "UAT deploy complete."
  when: manual
  environment:
    name: uat
  only:
    refs: [main]
# ---------------- DEPLOY TO PROD (simulated) ----------------
deploy_prod:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d postgres -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    echo "===== DEPLOY PROD (simulated) ====="
    exists=$(psql -h db -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='proddb';")
    if [ "$exists" != "1" ]; then
      psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE proddb;"
    fi
    liquibase --url="jdbc:postgresql://db:5432/proddb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
    echo "PROD deploy complete."
  when: manual
  environment:
    name: production
  only:
    refs: [main]
# ---------------- CLEANUP (mostly no-op; services are ephemeral) ----------------
rollback_clone:
  stage: cleanup
  image: alpine:latest
  before_script:
    - apk add --no-cache bash
  script:
    - echo "=== Starting rollback process (using artifacts) ==="
    - |
      if [ -f test_fail_employees ] || [ -f test_fail_department ]; then
        echo "Tests failed, restoring files from saved state..."
        cp -r ../good_state/* .
        echo "Rollback completed (files restored locally)."
      else
        echo "No rollback needed, tests passed."
      fi
  artifacts:
    name: "rollback_result_$CI_PIPELINE_ID"
    paths:
      - .
    expire_in: 1 week
  needs:
    - job: save_good_state
      artifacts: true
    - job: test_job
      artifacts: true
  when: on_failure
  only:
    refs: [main]
    