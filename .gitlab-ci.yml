image: registry.gitlab.com/fyjaan983/ci-cd-automation-through-jenkins/liquibase-psql:latest

stages:
  - docker_build
  - build
  - clone
  - test
  - deploy
  - cleanup

# ---------------- DOCKER BUILD & PUSH ----------------
docker_build:
  stage: docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script: |
    echo "Building custom Liquibase+psql Docker image..."
    docker build -t $CI_REGISTRY_IMAGE/liquibase-psql:latest .
    echo "Pushing image to GitLab registry..."
    docker push $CI_REGISTRY_IMAGE/liquibase-psql:latest
  only:
    refs: [main]

# ---------------- BUILD STAGE ----------------
build_job:
  stage: build
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  script: |
    echo "===== BUILD: validate changelog (Liquibase) ====="
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
    liquibase --url="jdbc:postgresql://db:5432/$POSTGRES_DB" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml validate
  artifacts:
    paths: [build_log.txt]
    expire_in: 1 week
  only:
    refs: [main]

# ---------------- CREATE TEMP CLONE DB (dump as artifact) ----------------
db_clone:
  stage: clone
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB to be ready ($i)"; sleep 2)
    done
  script: |
    set -e
    DBNAME="clone_${CI_COMMIT_SHORT_SHA}"
    echo "Creating temp DB: $DBNAME"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE IF EXISTS \"$DBNAME\";"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE \"$DBNAME\";"

    echo "Applying schema/data from repo into $DBNAME ..."
    if [ -f changelog.xml ]; then
      liquibase --url="jdbc:postgresql://db:5432/$DBNAME" \
                --username="$POSTGRES_USER" \
                --password="$POSTGRES_PASSWORD" \
                --changeLogFile=changelog.xml update
    else
      if ls sql/*.sql >/dev/null 2>&1; then
        for f in $(ls sql/*.sql | sort); do
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      else
        find . -maxdepth 2 -type f -name "*.sql" | sort | while read -r f; do
          psql -v ON_ERROR_STOP=1 -h db -U "$POSTGRES_USER" -d "$DBNAME" -f "$f"
        done
      fi
    fi

    echo "Dumping $DBNAME to artifact clone.dump"
    pg_dump -h db -U "$POSTGRES_USER" -d "$DBNAME" -Fc -f clone.dump
    printf "DBNAME=%s\n" "$DBNAME" > clone.env
  artifacts:
    reports:
      dotenv: clone.env
    paths:
      - clone.dump
      - clone.env
    expire_in: 2 hours
  only:
    refs: [main]

# ---------------- TEST JOB ----------------
test_job:
  stage: test
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
  needs: ["db_clone"]
  before_script: |
    export PGPASSWORD="$POSTGRES_PASSWORD"
    for i in $(seq 1 30); do
      psql -h db -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 1" && break || (echo "Waiting for DB ($i)"; sleep 2)
    done
    source clone.env
    echo "Testing DB: $DBNAME" | tee test_log.txt
    psql -h db -U "$POSTGRES_USER" -d postgres -c "DROP DATABASE IF EXISTS \"$DBNAME\";"
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE \"$DBNAME\";"
    pg_restore -h db -U "$POSTGRES_USER" -d "$DBNAME" --no-owner clone.dump >> test_log.txt 2>&1
  script: |
    echo "Database $DBNAME restored successfully from dump." | tee -a test_log.txt
  artifacts:
    paths: [test_log.txt]
    expire_in: 1 week
  only:
    refs: [main]

# ---------------- NOTIFICATION FUNCTION ----------------
# reusable before_script (sequence) that writes ~/.msmtprc and secures it
.setup_email: &setup_email
  - apk add --no-cache msmtp mailx >/dev/null 2>&1 || true
  - |
    cat > ~/.msmtprc <<EOF
    account default
    host smtp.gmail.com
    port 587
    auth on
    user fyjaan983@gmail.com
    password $SMTP_PASSWORD
    from fyjaan983@gmail.com
    tls on
    tls_starttls on
    EOF
  - chmod 600 ~/.msmtprc || true
# ---------------- DEPLOY TO UAT ----------------
deploy_uat:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: *setup_email
  script: |
    echo "===== DEPLOY UAT ====="
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE IF NOT EXISTS uatdb;"
    liquibase --url="jdbc:postgresql://db:5432/uatdb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
  after_script: |
    STATUS=$CI_JOB_STATUS
    if [ "$STATUS" = "success" ]; then
      echo "✅ UAT deployment succeeded for $CI_COMMIT_SHORT_SHA" | mail -s "UAT Deployment Success" fyjaan983@gmail.com
    else
      echo "❌ UAT deployment failed for $CI_COMMIT_SHORT_SHA" | mail -s "UAT Deployment Failed" fyjaan983@gmail.com
    fi
  when: manual
  environment:
    name: uat
  only:
    refs: [main]

# ---------------- DEPLOY TO PROD ----------------
deploy_prod:
  stage: deploy
  image: $CI_REGISTRY_IMAGE/liquibase-psql:latest
  services:
    - name: postgres:15
      alias: db
  variables:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
  before_script: *setup_email
  script: |
    echo "===== DEPLOY PROD ====="
    psql -h db -U "$POSTGRES_USER" -d postgres -c "CREATE DATABASE IF NOT EXISTS proddb;"
    liquibase --url="jdbc:postgresql://db:5432/proddb" \
              --username="$POSTGRES_USER" \
              --password="$POSTGRES_PASSWORD" \
              --changeLogFile=changelog.xml update
  after_script: |
    STATUS=$CI_JOB_STATUS
    if [ "$STATUS" = "success" ]; then
      echo "✅ PROD deployment succeeded for $CI_COMMIT_SHORT_SHA" | mail -s "PROD Deployment Success" fyjaan983@gmail.com
    else
      echo "❌ PROD deployment failed for $CI_COMMIT_SHORT_SHA" | mail -s "PROD Deployment Failed" fyjaan983@gmail.com
    fi
  when: manual
  environment:
    name: production
  only:
    refs: [main]

# ---------------- CLEANUP ----------------
rollback_clone:
  stage: cleanup
  image: postgres:15
  script: echo "Reverting back as there's a failure."
  when: on_failure
  needs: 
    - test_job
    - uat_deploy
    - prod_deploy
  only:
    refs: [main]
