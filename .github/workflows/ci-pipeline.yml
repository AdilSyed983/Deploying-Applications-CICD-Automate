name: CI/CD Pipeline (YAML + SQL + Liquibase)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  repo_lower: ${{ github.repository }}
  IMAGE_NAME: liquibase-psql
  IMAGE_TAG: latest
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  POSTGRES_DB: postgres
  DOCKER_NETWORK: ci_network

jobs:
  DOCKER_BUILD:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set lowercase repo name
        run: echo "repo_lower=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ghcr.io/${{ env.repo_lower }}/liquibase-psql:latest

  BUILD_JOB:
    name: Build & Validate Changelog
    runs-on: ubuntu-latest
    needs: DOCKER_BUILD
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v3

      - name: Wait for Postgres
        run: |
          for i in $(seq 1 30); do
            pg_isready -h localhost -p 5432 -U $POSTGRES_USER && break || (echo "Waiting for DB ($i)"; sleep 2)
          done

      - name: Run Liquibase validate in container
        run: |
          docker run --rm --network host \
            -v $GITHUB_WORKSPACE:/workspace \
            -w /workspace \
            ghcr.io/${{ env.repo_lower }}/liquibase-psql:latest \
            liquibase --url="jdbc:postgresql://localhost:5432/${POSTGRES_DB}" \
                      --username="${POSTGRES_USER}" \
                      --password="${POSTGRES_PASSWORD}" \
                      --changeLogFile=changelog.xml validate

  MANUAL_BACKUP:
    name: Save Repo Backup
    runs-on: ubuntu-latest
    needs: BUILD_JOB
    steps:
      - uses: actions/checkout@v3
      - name: Backup files
        run: |
          mkdir backup_state
          rsync -av --progress ./ ./backup_state --exclude backup_state
      - uses: actions/upload-artifact@v4
        with:
          name: backup_state
          path: backup_state/

  DB_CLONE:
    name: Clone Master DB
    runs-on: ubuntu-latest
    needs: MANUAL_BACKUP
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v3
      - name: Wait for Postgres
        run: |
          for i in $(seq 1 30); do
            pg_isready -h localhost -p 5432 -U $POSTGRES_USER && break || (echo "Waiting DB ($i)"; sleep 2)
          done
      - name: Create temp DB & apply schema
        run: |
          DBNAME="clone_${GITHUB_SHA::8}"
          psql -h localhost -U $POSTGRES_USER -d postgres -c "DROP DATABASE IF EXISTS \"$DBNAME\";"
          psql -h localhost -U $POSTGRES_USER -d postgres -c "CREATE DATABASE \"$DBNAME\";"
          if [ -f changelog.xml ]; then
            docker run --rm --network host \
              -v $GITHUB_WORKSPACE:/workspace \
              -w /workspace \
              ghcr.io/${{ env.repo_lower }}/liquibase-psql:latest \
              liquibase --url="jdbc:postgresql://localhost:5432/$DBNAME" \
                        --username="${POSTGRES_USER}" \
                        --password="${POSTGRES_PASSWORD}" \
                        --changeLogFile=changelog.xml update
          else
            for f in $(find sql -type f -name "*.sql" | sort); do
              psql -v ON_ERROR_STOP=1 -h localhost -U $POSTGRES_USER -d "$DBNAME" -f "$f"
            done
          fi
          pg_dump -h localhost -U $POSTGRES_USER -d "$DBNAME" -Fc -f clone.dump
      - uses: actions/upload-artifact@v4
        with:
          name: clone_db
          path: clone.dump

  TEST_JOB:
    name: Static Analysis & SQL Tests
    runs-on: ubuntu-latest
    needs: DB_CLONE
    steps:
      - uses: actions/checkout@v3
      - name: Run SQL static checks
        run: |
          if grep -i "insert" Employees.sql | awk -F'[(), ]+' '{for(i=1;i<=NF;i++) if(tolower($i)=="values"){print $(i+4)}}' | awk '{if($1<10000){echo "Fail"; exit 1}}'; then
            echo "Employees check passed"
          fi
          if grep -i "insert" Department.sql | awk -F'[(), ]+' '{for(i=1;i<=NF;i++) if(tolower($i)=="values"){print $(i+1)}}' | sort | uniq -d | grep .; then
            echo "Duplicate DEPT_ID found"; exit 1
          fi

  DEPLOY_UAT:
    name: Deploy to UAT (manual)
    runs-on: ubuntu-latest
    needs: TEST_JOB
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Simulate UAT deploy
        run: echo "Deploy to UAT done"

  DEPLOY_PROD:
    name: Deploy to Prod (manual)
    runs-on: ubuntu-latest
    needs: TEST_JOB
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Simulate PROD deploy
        run: echo "Deploy to PROD done"

  ROLLBACK_CLONE:
    name: Rollback if tests failed
    runs-on: ubuntu-latest
    needs: [MANUAL_BACKUP, TEST_JOB]
    if: failure()
    steps:
      - uses: actions/checkout@v3
      - name: Restore repo files
        run: |
          echo "Restoring repo from backup..."
          rsync -av --progress backup_state/ ./ --exclude backup_state
